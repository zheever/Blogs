# 数据挖掘实验报告
黄哲 15331126

## Python 多进程

### 1.选择计算方法
选择批量梯度上升法是因为每次迭代整个训练集都要计算梯度，但又互不影响，没有依赖关系和数据访问冲突问题。最终参数的更新在全部样本完成梯度计算之后进行汇合。

### 2.查看cpu信息
首先，要清楚所使用机器和并行化相关的配置，如在windows命令行界面输入wmic进入命令行系统管理执行脚本界面，cpu get * 查询cpu信息。

![查看cpu信息](./imgs/dataMining1.png)

```bash
C:\Users\哲>wmic
wmic:root\cli>cpu get *
AddressWidth：64
Architecture：9
NumberOfCores：2 #双核cpu
NumberOfLogicalProccessors：#四线程（超线程）
name：Inter(R) Core(TM) i5-5200U CPU @ 2.20GHz
Description：Intel64 Family 6 Model 61 Stepping 4
...
```
### 3.多进程
选择多进程而非多线程和Python并行化机制有关。有一个较为普遍的认识：
>python中的多线程其实并不是真正的多线程，如果想要充分地使用多核CPU的资源，在python中大部分情况需要使用多进程。（Python多进程编程）

由于本例中逻辑回归使用Python编程，且所使用的服务器十分符合多核CPU，Python还提供了好用的多进程包multiprocessing，本例采用Python多进程来对逻辑回归的批量梯度上升法进行并行化。
进一步参考为什么在Python里推荐使用多进程而不是多线程？，在Python多线程下，每个线程的执行方式是
1). 获取GIL(Global Interpreter Lock全局解释器锁)
2). 执行代码直到sleep或者是python虚拟机将其挂起。
3). 释放GIL

也就是说，进入CPU执行代码需要获得GIL，而在一个Python进程中，GIL只有一个，即使一个进程中有多线程也只有获得GIL的线程才能执行。非但如此，在释放GIL时的线程锁竞争、切换线程的会消耗资源。
而多进程的好处在于，每个进程有各自独立的GIL，互不干扰，利于并行执行，所以在python中，多进程的执行效率优于多线程(仅仅针对多核CPU而言)。

### 4.实现多进程
#### 使用multiprocessing
>python中的多线程其实并不是真正的多线程，如果想要充分地使用多核CPU的资源，在python中大部分情况需要使用多进程。Python提供了非常好用的多进程包multiprocessing，只需要定义一个函数，Python会完成其他所有事情。借助这个包，可以轻松完成从单进程到并发执行的转换。multiprocessing支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。

#### Process
创建进程的类：Process([group [, target [, name [, args [, kwargs]]]]])，target表示调用对象，args表示调用对象的位置参数元组。kwargs表示调用对象的字典。name为别名。group实质上不使用。
方法：is_alive()、join([timeout])、run()、start()、terminate()。其中，Process以start()启动某个进程。
属性：authkey、daemon（要通过start()设置）、exitcode(进程在运行时为None、如果为–N，表示被信号N结束）、name、pid。其中daemon是父进程终止后自动终止，且自己不能产生新进程，必须在start()之前设置。

示例代码

```
import multiprocessing
import time
 
def worker_1(interval):
    print "worker_1"
    time.sleep(interval)
    print "end worker_1"
 
def worker_2(interval):
    print "worker_2"
    time.sleep(interval)
    print "end worker_2"
 
def worker_3(interval):
    print "worker_3"
    time.sleep(interval)
    print "end worker_3"
 
if __name__ == "__main__":
    p1 = multiprocessing.Process(target = worker_1, args = (2,))
    p2 = multiprocessing.Process(target = worker_2, args = (3,))
    p3 = multiprocessing.Process(target = worker_3, args = (4,))
 
    p1.start()
    p2.start()
    p3.start()
 
    print("The number of CPU is:" + str(multiprocessing.cpu_count()))
    for p in multiprocessing.active_children():
        print("child   p.name:" + p.name + "\tp.id" + str(p.pid))
    print "END!!!!!!!!!!!!!!!!!"
```
##### 主要代码
```
def batch_grad_ascent_nulti_process(data_nat, label_nat, valdata_nat, vallabel_nat, \
                                processNum=18, numIter=N_ITER):
    _weights = Array('f', range(N_FEATURE + 1))
    alpha = ALPHA
    weights = [random.random() for i in range(N_FEATURE + 1)]  # random init

    sample_num = len(data_nat)
    if sample_num < processNum:
        processNum = sample_num
    step = int(sample_num / processNum)  # workload of each process

    total_time = 0.0
    for iter in range(numIter):
        start = time.time()
        lock = Lock()
        for i in range(len(weights)): _weights[i] = weights[i]

        processes = []  # list
        for i in range(0, sample_num, step):
            if i + step > sample_num:
                continue
            process = Process(target=calc_grad, \
                              args=(_weights, alpha, data_nat[i:i + step], label_nat[i:i + step], lock))
            processes.append(process)

        for i in range(len(processes)):
            processes[i].start()

        for i in range(len(processes)):
            processes[i].join()

        weights = [_weights[i] for i in range(N_FEATURE + 1)]
        end = time.time()
        total_time = total_time + float(end - start)
        calc_acc(weights, valdata_nat, vallabel_nat, iter)
    print('batch_grad_ascent_nulti_process iter cost:', float(total_time) / numIter, \
          's in average. processNum:', processNum)
    return weights
```
##### 结果截图
**单进程**

![运行结果1](./imgs/dataMining10.png)

**2进程**

![运行结果2](./imgs/dataMining9.png)

**4进程**

![运行结果3](./imgs/dataMining11.png)

**8进程**

![运行结果4](./imgs/dataMining4.png)

**16进程**

![运行结果5](./imgs/dataMining5.png)

**32进程**

![运行结果6](./imgs/dataMining6.png)

**64进程**

![运行结果7](./imgs/dataMining7.png)

**128进程**

![运行结果8](./imgs/dataMining8.png)


